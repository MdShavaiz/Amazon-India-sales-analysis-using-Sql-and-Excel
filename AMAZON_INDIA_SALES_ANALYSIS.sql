USE AMAZON_DB;

-- BUSINESS PROBLEM 1 

-- P1) WHAT IS THE TOTAL REVENUE GENERATED ?
-- P2) HOW MANY PRODUCTS DO WE HAVE ?
-- P3) FIND OUT TOP 5 ORDERS DETAILS BY SALES AMOUNT .
-- P4) WHAT IS THE AVERAGE SALE VALUE?
-- P5) WHAT IS THE TOTAL SALE FOR GOA ?
-- P6) HOW MANY UNIQUE CUSTOMERS HAVE PLACED ORDERS?


-- P1 ) WHAT IS THE TOTAL REVENUE GENERATED ?

SELECT 
       ROUND(SUM(SALE)) AS TOTAL_REVENUE
FROM ORDERS;  

-- P2) HOW MANY PRODUCTS DO WE HAVE ?

SELECT 
       COUNT(DISTINCT PRODUCT_ID) AS TOTAL_PRODUCTS
FROM ORDERS;    

-- P3) FIND OUT TOP 5 ORDERS DETAILS BY SALES AMOUNT .

SELECT * 
FROM ORDERS
ORDER BY SALE DESC
LIMIT 5; 
                               
-- P4) WHAT IS THE AVERAGE SALE VALUE?

SELECT 
       AVG(SALE) AS AVERAGE_SALE_VALUE
FROM ORDERS;    

-- P5) WHAT IS THE TOTAL SALE FOR GOA ?

SELECT 
	  SUM(SALE) AS TOTAL_SALES_GOA
FROM ORDERS
WHERE STATE = "GOA";     


-- P6) HOW MANY UNIQUE CUSTOMERS HAVE PLACED ORDERS?

SELECT 
	COUNT(DISTINCT CUSTOMER_ID) AS TOTAL_CUSTOMERS
FROM ORDERS;  
              
              
-- Business Problem 2 ()
 -- P1 FIND THE TOP 5 STATES WITH THE HIGHEST TOTAL SALES REVENUE FROM ORDERS
 -- P2 HOW MANY ORDERS WERE PLACED BY EACH CUSTOMERS , AND WHAT IS THEIR AVERAGE ORDER QUANTITY ?
 -- P3 WHICH CATEGORY HAS THE HIGHEST AVERAGE SALE AMOUNT PER ORDER ?
 -- P4 IDENTIFY THE TOP 3 BEST- SELLING PRODUCTS ( SUB CATEGGORIES) IN TERMS OF TOTAL QUANTITY SOLD.
 -- P5 WHICH IS THE BEST SELLING MONTH IN 2022 BASED ON REVENUE ?
 -- P6 FIND TOP 3 PRODUCTS AND REVENUE GENERATED IS MORE THAN 20000 .
 

 -- P1)FIND THE TOP 5 STATES WITH THE HIGHEST TOTAL SALES FROM ORDERS
SELECT  STATE ,
		SUM(SALE) AS TOTAL_REVENUE
FROM ORDERS
GROUP BY STATE
ORDER BY TOTAL_REVENUE DESC
LIMIT 5;                       -- IN TOP 5 STATES BY HIGHEST SALES WE DO NOT HAVE ANY LARGEST POPULATED STATE NAME EXCEPT TAMIL-NADU
                                                                                                                                       

-- P2 HOW MANY ORDERS WERE PLACED BY EACH CUSTOMERS , AND WHAT IS THEIR AVERAGE AND SLAES ORDER QUANTITY ?

SELECT CUSTOMER_ID,
         COUNT(ORDER_ID) AS TOTAL_ORDERS,
         AVG(SALE) AS AVERAGE_ORDERS,
         SUM(SALE) AS TOTAL_SALE
FROM ORDERS
GROUP BY CUSTOMER_ID;

--  P3 WHICH CATEGORY HAS THE HIGHEST AVERAGE SALE AMOUNT PER ORDER ?
SELECT 
	  CATEGORY ,
	  AVG(SALE) AS AVG_SALE_AMOUNT
FROM ORDERS
GROUP BY CATEGORY
ORDER BY AVG_SALE_AMOUNT DESC
LIMIT 1;
																																						    
-- P4 IDENTIFY THE TOP 3 BEST- SELLING PRODUCTS ( SUB CATEGGORIES) IN TERMS OF TOTAL QUANTITY SOLD.

SELECT 
      SUB_CATEGORY ,
	  SUM(QUANTITY) AS TOTAL_QUANTITY_SOLD
FROM ORDERS
GROUP BY SUB_CATEGORY
ORDER BY TOTAL_QUANTITY_SOLD DESC
LIMIT 3;                                                                                                                                                       


-- P5 WHICH IS THE BEST SELLING MONTH IN 2022 BASED ON REVENUE ?

SELECT 
       MONTHNAME(ORDER_DATE) AS MONTHS,
         ROUND(SUM(SALE)) AS TOTAL_SALES
FROM ORDERS
WHERE YEAR(ORDER_DATE) = "2022"
GROUP BY MONTHS
ORDER BY TOTAL_SALES DESC
LIMIT 1;


 -- P6) FIND TOP 3 PRODUCTS AND REVENUE GENERATED IS MORE THAN 20000 .
 
 SELECT 
          PRODUCT_ID , 
          SUM(SALE) AS TOTAL_REVENUE
FROM ORDERS
GROUP BY PRODUCT_ID
HAVING SUM(SALE) > 20000
ORDER BY TOTAL_REVENUE DESC
LIMIT 3;


-- BUSINESS PROBLEM 3 

-- P1) FIND CUSTOMERS NAME AND TOTAL ORDERS AND TOTAL REVENUE 
-- P2) IDENTIFY ALL ORDERS THAT HAVE BEEN RETURNED , ALONG WITH THE DETAILS OF THE RETURN (IF AVAILABLE).
-- P3) FIND ALL INSTANCES WHERE PRODUCTS HAVE BEEN SOLD , RETURNED  , OR BOTH , ALONG WITH THE ASSOCIATED DETAILS.
-- P4) WHICH 5 STATES HAVE THE HIGHEST TOTAL NUMBER OF ORDERS WHERE EACH STATE'S TOTAL SALES EXCEED THE AVERAGE TOTAL SALES OF ALL STATES?
-- P5) WHICH 5 PRODUCTS HAVE THE HIGHEST TOTAL SALES WHERE EACH PRODUCT'S TOTAL SALES EXCEED THE AVERAGE TOTAL SALES OF ALL PRODUCTS;


-- P1) FIND CUSTOMERS NAME AND TOTAL ORDERS AND TOTAL REVENUE 

SELECT
      C.CUSTOMER_ID ,
      C.CUSTOMER_NAME,
      COUNT(O.ORDER_ID) AS TOTAL_ORDERS,
      SUM(O.SALE) AS TOTAL_SALES
FROM ORDERS AS O
INNER JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID
GROUP BY C.CUSTOMER_ID , C.CUSTOMER_NAME;


-- P2) IDENTIFY ALL ORDERS THAT HAVE BEEN RETURNED , ALONG WITH THE DETAILS OF THE RETURN (IF AVAILABLE).

SELECT * 
FROM ORDERS AS O
LEFT JOIN RETURNS AS R             -- USING LEFT JOIN SO THAT , THE DATA COMES TO THE ORDERS TABLE WILL HOLD BOTH RETURNING AND NON RETURNING DETAILS--
ON O.ORDER_ID = R.ORDER_ID;

-- CHECK ONLY FOR RETURN ORDERS

SELECT * 
FROM ORDERS
WHERE ORDER_ID IN (SELECT ORDER_ID FROM RETURNS);

-- SELECT COUNT(*) FROM RETURNS;


-- P3) FIND ALL INSTANCES WHERE PRODUCTS HAVE BEEN SOLD , RETURNED  , OR BOTH , ALONG WITH THE ASSOCIATED DETAILS.

SELECT * 
FROM ORDERS AS O
INNER JOIN PRODUCTS AS P
ON O.PRODUCT_ID = P.PRODUCT_ID
LEFT JOIN RETURNS AS R
ON O.ORDER_ID = R.ORDER_ID;


-- P4) WHICH 5 STATES HAVE THE HIGHEST TOTAL NUMBER OF ORDERS WHERE EACH STATE'S TOTAL SALES EXCEED THE AVERAGE TOTAL SALES OF ALL STATES?


WITH SALES AS (SELECT STATE ,
                           SUM(SALE) AS TOTAL_SALES,
                           COUNT(ORDER_ID) AS TOTAL_ORDERS
				FROM ORDERS
                GROUP BY STATE),          -- THIS TABLE WILL GIVE TOTAL SALES BY EACH STATE
                
		AVG_SALES AS (SELECT AVG(TOTAL_SALES) AS AVG_SALE
                           FROM SALES)           -- THIS TABLE WILL GIVE AVG OF THE TOTAL SALES BY EACH STATE
                           
                           
        SELECT S.STATE , S.TOTAL_SALES , A.AVG_SALE
        FROM SALES AS S
        JOIN AVG_SALES AS A   -- COMPARING TOTAL SALES AGAINST AVG SALE BY EACH STATE TO GET TOP 5 STATES  WHERE SALES IS MORE THAN AVG SALE 
        ON S.TOTAL_SALES > A.AVG_SALE
        ORDER BY TOTAL_ORDERS DESC 
        LIMIT 5;

        

-- P5) WHICH 5 PRODUCTS HAVE THE HIGHEST TOTAL SALES WHERE EACH PRODUCT'S TOTAL SALES EXCEED THE AVERAGE TOTAL SALES OF ALL PRODUCTS;


WITH PRODUCT_SALES AS (
    SELECT P.PRODUCT_ID,
           P.PRODUCT_NAME,
           SUM(O.SALE) AS TOTAL_SALES
    FROM ORDERS AS O
    INNER JOIN PRODUCTS AS P                -- FIRST JOIN THE PRODUCT AND THE ORDERS TABLE TO GET THE TOTAL_SALES
    ON O.PRODUCT_ID = P.PRODUCT_ID
    GROUP BY P.PRODUCT_ID, P.PRODUCT_NAME
),
PRODUCT_AVG_SALES AS (
    SELECT AVG(TOTAL_SALES) AS AVG_SALES     -- HERE WE ARE GETTING AVERAGE SALES OF OUR JOINING TABLE'S SALES
    FROM PRODUCT_SALES
)
SELECT P.PRODUCT_ID,
       P.PRODUCT_NAME,  -- NOW COMPARING BOTH THE TABLE TO GET WHICH ARE THE TOP 5 PRODUCTS WE ARE GETTING MORE SALES THAN AVG SALES
                                              
       P.TOTAL_SALES,
       S.AVG_SALES
FROM PRODUCT_SALES AS P ,PRODUCT_AVG_SALES AS S
WHERE P.TOTAL_SALES > (SELECT AVG_SALES FROM PRODUCT_AVG_SALES)
ORDER BY P.TOTAL_SALES DESC
LIMIT 5;


-- BUSINESS PROBLEM 4
-- P1) IDENTIFY RETURNING CUSTOMERS: LABEL CUSTOMERS AS "RETURNING" IF THEY HAVE PLACED MORE THAN ONE "RETURNS",
--    OTHERWISE , MARK THEM AS "NEW"
-- P2) CLASSIFY ORDERS BY QUANTITY : CATEGORIZE ORDERS AS "LOW","MEDIUM" OR "HIGH" BASED ON THE QUANTITY ORDERED.


-- P1) IDENTIFY RETURNING CUSTOMERS: LABEL CUSTOMERS AS "RETURNING" IF THEY HAVE PLACED MORE THAN ONE "RETURNS",
--    OTHERWISE , MARK THEM AS "NEW"

SELECT C.CUSTOMER_ID ,
       C.CUSTOMER_NAME,
       COUNT(O.ORDER_ID) AS TOTAL_ORDERS,
       COUNT(R.RETURN_ID),
        CASE
            WHEN COUNT(R.ORDER_ID) > 1 THEN "RETURNS CUSTOMERS"
            ELSE "NEW_CUSTOMERS"
            END AS RETURNING_STATUS
FROM ORDERS AS O
INNER JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID
LEFT JOIN RETURNS AS R
ON O.ORDER_ID = R.ORDER_ID
GROUP BY C.CUSTOMER_ID , C.CUSTOMER_NAME;

-- P2) CLASSIFY ORDERS BY QUANTITY : CATEGORIZE ORDERS AS "LOW","MEDIUM" OR "HIGH" BASED ON THE QUANTITY ORDERED.

-- SELECT DISTINCT QUANTITY FROM ORDERS ORDER BY QUANTITY;

--    SELECT MIN(QUANTITY) , MAX(QUANTITY) , AVG(QUANTITY) 
--    FROM ORDERS;

SELECT        
               CASE      #1 this column position is 1st in our query
               WHEN QUANTITY > 10 THEN "HIGH QUANTITY "
               WHEN QUANTITY BETWEEN 4 AND 10 THEN "MEDIUM QUANTITY"
               ELSE "LOW QUANTITY "
               END AS QTY_STATUS , COUNT(ORDER_ID) AS TOTAL_ORDERS
FROM ORDERS
			GROUP BY  1;   #we used 1st here based on above condition
            


-- BUSINESS PROBLEM 5

-- P1) INDENTIFY THE MOST EXPENSIVE, LEAST.EXP. AND SECOND MOST EXP. PRODUCT NAME UNDER EACH CATEGORY.
-- P2) WHICH ARE THE PRODUCT'S RESPONSIBLE FOR OUR TOP 30 % OF THE SALES BASED ON CUMULATIVE DISTRIBUTION.
-- P3) FIND THE BEST SELLING YEAR OVERALL.
-- P4) IDENTIFY YEAR-ON-YEAR SALES GROWTH OR DECLINE WITH PERCENTAGE CHANGE.
-- P5) YEAR 2023 SALES AND CURRENT_YARS_SALES COMPARISION
-- P6 ) QUARTER WISE SALES FOR EACHYEAR
-- P7) WHIHC CUSTOMER HAD THE HIGHEST TOTAL SALES IN EACH YEAR ?



-- P1) INDENTIFY THE MOST EXPENSIVE, LEAST.EXP. AND SECOND MOST EXP. PRODUCT NAME UNDER EACH CATEGORY.
WITH FILTEREDORDERS AS (
    SELECT 
        O.PRODUCT_ID,
        NULLIF(O.CATEGORY, '') AS CATEGORY, -- CONVERT EMPTY STRINGS TO NULL
        O.SALE
    FROM 
        ORDERS AS O
    WHERE 
        NULLIF(O.CATEGORY, '') IS NOT NULL -- FILTER AFTER NULLIF CONVERSION
)
SELECT 
    P.PRODUCT_ID,
    P.PRODUCT_NAME,
    F.CATEGORY,
    F.SALE,
    FIRST_VALUE(P.PRODUCT_NAME) OVER W AS MOST_EXP_PRODUCT,   -- WILL MOST EXPENSIVE PRODUCT
    LAST_VALUE(P.PRODUCT_NAME) OVER W  AS LEAST_EXP_PRODUCT,  -- WILL GIVE LEAST EXPENSIVE PRODUCT
    NTH_VALUE(P.PRODUCT_NAME, 2) OVER W AS SECOND_MOST_EXP_PRODUCT -- WILL GIVE SECOND EXPENSIVE PRODUCT
FROM 
    FILTEREDORDERS AS F
INNER JOIN 
    PRODUCTS AS P
ON 
    F.PRODUCT_ID = P.PRODUCT_ID
WHERE 
    F.CATEGORY IS NOT NULL 
															  -- WE JUST USE W RATHER THAN WRITING WHOLE WINDOW FUNCTION 
    WINDOW W AS (PARTITION BY F.CATEGORY ORDER BY F.SALE DESC          -- THIS FRAME CLAUSE IS USING FOR FINDING MOST ,LEAST , END MOST EXP PRODUCTS RESPECTIVELY.
                                       RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)  ; 
                                       
                                       
-- P2) WHICH ARE THE PRODUCT'S RESPONSIBLE FOR OUR TOP 30 % OF THE SALES BASED ON CUMULATIVE DISTRIBUTION. 

SELECT PRODUCT_NAME, CONCAT(CUMMULATIVE_DISTRIBUTION, "%") AS CUMMULATIVE_DISTRIBUTION , SALE
FROM (
    SELECT 
        P.PRODUCT_NAME,
        SALE,
        ROUND(CUME_DIST() OVER (ORDER BY O.SALE DESC) * 100, 2) AS CUMMULATIVE_DISTRIBUTION
    FROM ORDERS AS O
    INNER JOIN PRODUCTS AS P
    ON O.PRODUCT_ID = P.PRODUCT_ID
) AS CUM_TABLE
WHERE CUMMULATIVE_DISTRIBUTION < 30;


-- P3) FIND THE BEST SELLING YEAR OVERALL 

SELECT 
       YEAR(ORDER_DATE) AS TOTAL_YEARS,
       SUM(SALE) AS TOTAL_SALES
FROM ORDERS
GROUP BY TOTAL_YEARS 
ORDER BY TOTAL_SALES DESC;       

-- P4) IDENTIFY YEAR-ON-YEAR SALES GROWTH OR DECLINE WITH PERCENTAGE CHANGE.
WITH SALESDATA AS (SELECT 
						  YEAR(ORDER_DATE) AS TOTAL_YEARS,
						  SUM(SALE) AS TOTAL_SALES
					FROM ORDERS
                            GROUP BY TOTAL_YEARS),    #AGGREGATING EACH YEAR SALE
                            
		SALESCOMPARISION AS ( SELECT TOTAL_YEARS,
                                         TOTAL_SALES ,
							LAG(TOTAL_SALES) OVER (ORDER BY TOTAL_YEARS) AS PREVIOUS_YEAR_SALES  # CALCULATING PREVIOUS YEAR SALES
                            FROM SALESDATA
                            )


# CALCULATING PERCENTAGE GROWTH WEATHER IT IS INCREASING OR DECREASING
SELECT TOTAL_YEARS,
         TOTAL_SALES,
         PREVIOUS_YEAR_SALES,
         CASE
            WHEN PREVIOUS_YEAR_SALES IS NULL THEN NULL
            ELSE
		ROUND((TOTAL_SALES - PREVIOUS_YEAR_SALES) / PREVIOUS_YEAR_SALES * 100 ,2)
        END AS PERCENTAGE_GROWTH_OR_DECLINE
        FROM SALESCOMPARISION;
        
         
-- 2023 SALES AND CURRENT_YARS_SALES COMPARISION
                                        
WITH SALESDATA AS (
    SELECT 
        YEAR(ORDER_DATE) AS TOTAL_YEARS,
        SUM(SALE) AS TOTAL_SALES
    FROM ORDERS
    WHERE YEAR(ORDER_DATE) = 2023
    GROUP BY TOTAL_YEARS           -- SALES FOR YEAR 2023
),
CURRENT_YEAR_SALES AS (
    SELECT 
        YEAR(ORDER_DATE) AS TOTAL_YEARS,
        SUM(SALE) AS TOTAL_SALES
    FROM ORDERS
    WHERE YEAR(ORDER_DATE) = YEAR(CURDATE())
    GROUP BY TOTAL_YEARS          -- SALES FOR CURRENT YEAR
)
SELECT 
    C.TOTAL_SALES AS CURRENT_YEAR_SALES, 
    S.TOTAL_SALES AS SALES_2023, 
    ROUND(((C.TOTAL_SALES - S.TOTAL_SALES) / S.TOTAL_SALES) * 100,2) AS GROWTH_OR_DECLINE_PERCENTAGE  -- CALCULATING GROWTH_OR_DECLINE_PERCENTAGE
FROM 
    SALESDATA AS S,
    CURRENT_YEAR_SALES AS C;           
                     
-- P6 ) QUARTER WISE SALES FOR EACHYEAR

SELECT 
      YEAR(ORDER_DATE) AS TOTAL_YEARS,
      QUARTER(ORDER_DATE) AS TOTAL_QUARTERS,
      SUM(SALE) AS TOTAL_SALES
      FROM ORDERS
      GROUP BY TOTAL_YEARS , TOTAL_QUARTERS
      ORDER BY TOTAL_QUARTERS , TOTAL_YEARS;
      

--  WHY WE HAVE LESS SALES IN YEAR 2024 AS COMPAIR TO 2023
--   BECAUSE WE HAVE JUST SALES DATA 2024 OF ONLY TWO MONTHS -- JAN AND --FEB AS COMPARE TO 2023 SALES WHICH HAS DATA OF ALL 12 MONTHS
--   BELOW QUERY SHOWING THAT

         SELECT 
    MONTHNAME(ORDER_DATE) AS MONTHS,
    QUARTER(ORDER_DATE) AS TOTAL_QUARTERS,
    SUM(SALE) AS TOTAL_SALES,
    2023 AS YEAR
FROM ORDERS                           -- APPENDING TABLE TOGETHER TO COMPARE THE TOTAL NO OF QUARTER EACH YEAR HAS (2023 AND 2024)
WHERE YEAR(ORDER_DATE) = 2023
GROUP BY MONTHS, TOTAL_QUARTERS

UNION ALL

SELECT 
    MONTHNAME(ORDER_DATE) AS MONTHS,
    QUARTER(ORDER_DATE) AS TOTAL_QUARTERS,
    SUM(SALE) AS TOTAL_SALES,
    2024 AS YEAR
FROM ORDERS
WHERE YEAR(ORDER_DATE) = 2024
GROUP BY MONTHS, TOTAL_QUARTERS

ORDER BY YEAR ASC, TOTAL_QUARTERS ASC;



-- P7) WHICH CUSTOMER HAS THE HIGHEST TOTAL SALES IN EACH YEAR ?

select * 
from (
select 
        year(order_date) as total_years,
        customer_id,
        sum(sale) total_sales,
dense_rank() over (partition by year(order_date) order by sum(sale) desc) as sal_rn
from 
     orders
     group by total_years , order_id) x
     where sal_rn = 1;
     
     
-- BEHAVIOUR ANALYSIS

-- IDENTIFY WHEN A CUSTOMER'S PURCHASING BEHAVIOUR CHNAGES SIGNIFICANTLY BY COMPARING THEIR CURRENT PURCHASE TO THEIR 
 --  LAST PURCHASE
 
 
 SELECT 
        O.CUSTOMER_ID ,
        C.CUSTOMER_NAME,
         O.ORDER_DATE ,
         O.SALE,
LAG(O.SALE) OVER (PARTITION BY O.CUSTOMER_ID ORDER BY O.ORDER_DATE) AS PREVIOUS_PURCHASE,
SALE - LAG(O.SALE) OVER (PARTITION BY O.CUSTOMER_ID ORDER BY O.ORDER_DATE) AS PURCHASE_DIFF
FROM ORDERS AS O
JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID;

-- GET A LIST OF CUSTOMERS WHO HAVE'NT PLACED AN ORDER

SELECT C.CUSTOMER_ID ,
         C.CUSTOMER_NAME,
       COUNT(O.ORDER_ID) AS TOTAL_ORDERS
FROM ORDERS AS O
LEFT JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID
GROUP BY C.CUSTOMER_ID , C.CUSTOMER_NAME
HAVING COUNT(O.ORDER_ID) < 1 ;        -- EVERY CUSTOMER HAVE PLACED ORDERS


-- FIND THE 3 MOST POPULAR PRODUCTS BY NO OF ORDERS.

SELECT 
      P.PRODUCT_NAME,
     COUNT(O.ORDER_ID) AS TOTAL_ORDERS
FROM 
 ORDERS AS O
 JOIN PRODUCTS AS P
  ON O.PRODUCT_ID = P.PRODUCT_ID
GROUP BY P.PRODUCT_NAME
ORDER BY TOTAL_ORDERS DESC
LIMIT 3;


-- LIST OF ALL THE PRODUCTS THAT HAVE NEVER BEEN ORDERED 
SELECT PRODUCT_ID , PRODUCT_NAME
FROM PRODUCTS
WHERE PRODUCT_ID NOT IN (SELECT PRODUCT_ID FROM ORDERS)
;

-- FACTORS AFFECTING THE SALES

SELECT STATE, SUM(SALE) AS TOTAL_SALES
FROM ORDERS
GROUP BY STATE;  -- THERE IS NO ISSUE WITH THE SALES AMOUNTS ACROSS DIFFERENT STATES; ALL SALES ARE COMPARABLE. 
					--  WE ARE TRYING TO DETERMINE THE SMALLEST SALE AMOUNT TO UNDERSTAND ITS IMPACT.

                        
            WITH LARGEST_POPULATION_STATES AS (
    SELECT MIN(O.SALE) AS MIN_SALE, 
           MAX(O.SALE) AS MAX_SALE, 
           SUM(O.SALE) AS TOTAL_SALE, 
           COUNT(*) AS ORDER_COUNT, 
           COUNT(C.CUSTOMER_ID) TOTAL_CUSTOMERS,
           O.STATE
    FROM ORDERS  AS O
    LEFT JOIN CUSTOMERS AS C
    ON O.CUSTOMER_ID = C.CUSTOMER_ID
    WHERE O.STATE IN ('UTTAR PRADESH', 'MAHARASHTRA', 'BIHAR', 'WEST BENGAL', 'MADHYA PRADESH')
    GROUP BY O.STATE
),
SMALLEST_POPULATION_STATES AS (
    SELECT MIN(SALE) AS MIN_SALE, 
           MAX(SALE) AS MAX_SALE, 
           SUM(SALE) AS TOTAL_SALE, 
           COUNT(*) AS ORDER_COUNT,
           COUNT(C.CUSTOMER_ID) TOTAL_CUSTOMERS,
           O.STATE
    FROM ORDERS  AS O
    LEFT JOIN CUSTOMERS AS C
    ON O.CUSTOMER_ID = C.CUSTOMER_ID
    WHERE O.STATE IN ("GOA" ,"SIKKIM","TRIPURA","NAGALAND","MIZORAM")
    GROUP BY O.STATE
)
SELECT 'LARGEST_POPULATION' AS CATEGORY, TOTAL_CUSTOMERS,MIN_SALE, MAX_SALE, TOTAL_SALE, ORDER_COUNT, STATE
FROM LARGEST_POPULATION_STATES
UNION ALL
SELECT 'SMALLEST_POPULATION' AS CATEGORY,TOTAL_CUSTOMERS, MIN_SALE, MAX_SALE, TOTAL_SALE, ORDER_COUNT, STATE
FROM SMALLEST_POPULATION_STATES;


SELECT O.STATE AS TOTAL_STATES,
        COUNT(C.CUSTOMER_ID)  TOTAL_CUSTOMERS,
        SUM(O.SALE) AS TOTAL_SALES
FROM ORDERS AS O
LEFT JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID
GROUP BY TOTAL_STATES
ORDER BY TOTAL_CUSTOMERS ASC
;  

-- BASED ON THE ABOVE QUERIES, EVEN THOUGH "WEST BENGAL" AND "MAHARASHTRA"
-- HAVE A GOOD CUSTOMER BASE, THE OTHER THREE LARGEST STATES—MADHYA PRADESH,
-- UTTAR PRADESH, AND BIHAR—DO NOT HAVE AS MANY CUSTOMERS. HOWEVER, THE SALES OF
-- ALL TOP 5 STATES ARE COMPARATIVELY LESS THAN THOSE OF THE SMALLER POPULATION
-- STATES LIKE TRIPURA, SIKKIM , HIMACHAL PRADESH, JHARKHAND, GOA, AND TELANGANA.


--  ADDRESS PROBLEMS -----------------------------------------------------------------------------------------------------------------------

-- TO ADDRESS THESE PROBLEMS, WE NEED TO ENSURE THAT OUR PRODUCTS ARE REACHING CUSTOMERS PROPERLY.
-- IDENTIFY THE CATEGORIES CUSTOMERS ARE REQUESTING.
-- ASSESS THE QUALITY OF SALESPEOPLE.
-- EVALUATE CUSTOMER CARE SERVICES.
-- ANALYZE THE COMPETITORS.
-- TO INCREASE SALES, WE CAN CONDUCT CAMPAIGNS (PROMOTIONS).
-- FOCUS ON EXISTING CUSTOMERS.
-- IDENTIFY CUSTOMERS WHO HAVE BEEN INACTIVE FOR OVER A YEAR.


-- STATES_WHERE_ADDING_30000_CAN_EXCEED_CURRENT_MAX_SALE
WITH CURRENT_MAX_SALES AS (
    SELECT MAX(SALE) AS MAX_SALE
    FROM ORDERS
),
STATES_WITH_POTENTIAL AS (
    SELECT STATE
    FROM ORDERS
    GROUP BY STATE
    HAVING MAX(SALE) + 30000 > (SELECT MAX(SALE) FROM ORDERS)
)
SELECT STATE
FROM STATES_WITH_POTENTIAL;  -- WITH THE HELP OF THIS OPERATION, WE COULD POTENTIALLY INCREASE SALES IN AT LEAST
                             -- THREE OF THE LARGEST POPULATION STATES, SUCH AS UTTAR PRADESH, MADHYA PRADESH, AND MAHARASHTRA.


-- INACTIVE_CUSTOMERS_SINCE_LAST_YEAR
WITH RECENT_ORDERS AS (
    SELECT DISTINCT CUSTOMER_ID
    FROM ORDERS
    WHERE ORDER_DATE >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)
),
INACTIVE_CUSTOMERS AS (
    SELECT CUSTOMER_ID
    FROM CUSTOMERS
    WHERE CUSTOMER_ID NOT IN (SELECT CUSTOMER_ID FROM RECENT_ORDERS)
)
SELECT C.CUSTOMER_ID, C.CUSTOMER_NAME
FROM CUSTOMERS C
JOIN INACTIVE_CUSTOMERS IC ON C.CUSTOMER_ID = IC.CUSTOMER_ID;



-- END OF PROJECT ------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------



-- USING SQL QUERIES FOR EXCEL VISUALIZATION -----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- TOTAL REVENUE
SELECT ROUND(SUM(SALE)) AS TOTAL_REVENUE
FROM ORDERS; 

-- TOTAL_ORDERS
SELECT COUNT(ORDER_ID) FROM ORDERS;   

-- CUSTOMER WHO HAS PLACED THE ORDERS
SELECT COUNT(CUSTOMER_ID) 
FROM CUSTOMERS
WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM ORDERS);


-- TOTAL PRODUCTS SOLD
SELECT COUNT(PRODUCT_ID)
FROM PRODUCTS
WHERE PRODUCT_ID IN (SELECT PRODUCT_ID FROM ORDERS);



SELECT COUNT(DISTINCT STATE)
FROM orders
WHERE STATE IS NOT NULL AND TRIM(STATE) <> '';  -- 28  EXCLUDING BLANK 28 STATES (INDIA HAS 28 STATES)

SELECT COUNT( DISTINCT STATE)
FROM ORDERS
WHERE STATE IS NOT NULL;    -- IT IS INCLUDING BLANK AS VALUES FOR STATE   -- 29 STATES



SELECT COUNT(DISTINCT CATEGORY)
FROM ORDERS
WHERE TRIM(CATEGORY) <> '' AND CATEGORY IS NOT NULL;   -- EXCLUDING BLANK'S

SELECT COUNT(DISTINCT CATEGORY)
FROM ORDERS
WHERE STATE IS NOT NULL; -- 4



 -- P1)FIND THE TOP 5 STATES WITH THE HIGHEST TOTAL SALES REVENUE FROM ORDERS
SELECT  STATE ,
		SUM(SALE) AS TOTAL_REVENUE
FROM ORDERS                             
GROUP BY STATE
ORDER BY TOTAL_REVENUE DESC
LIMIT 5; 

-- P4 IDENTIFY THE TOP 5 BEST- SELLING PRODUCTS BY NO. OF ORDERS

SELECT  P.PRODUCT_NAME,
        COUNT(O.ORDER_ID)  TOTAL_ORDERS
FROM ORDERS AS O
JOIN PRODUCTS AS P
ON O.PRODUCT_ID = P.PRODUCT_ID
GROUP BY P.PRODUCT_NAME
ORDER BY TOTAL_ORDERS DESC
LIMIT 5;                      

--  TOTAL SALES BY CATEGORY


SELECT 
    SUM(SALE) AS TOTAL_SALES, 
    COALESCE(NULLIF(TRIM(CATEGORY), ''), 'OTHERS') AS CATEGORY
FROM 
    ORDERS
GROUP BY 
    COALESCE(NULLIF(TRIM(CATEGORY), ''), 'OTHERS');

-- MONTHLY AND QUARTELY SALES

SELECT 
            MONTHNAME(ORDER_DATE) AS TOTAL_MONTHS,
            QUARTER(ORDER_DATE) AS TOTAL_QUARTER,
            SUM(SALE) AS TOTAL_SALES
            FROM ORDERS
            GROUP BY TOTAL_MONTHS , TOTAL_QUARTER
            ORDER BY TOTAL_QUARTER;
            
-- TOTAL SALES BY YEARS

SELECT 
       YEAR(ORDER_DATE) AS TOTAL_YEARS,
       SUM(SALE) AS TOTAL_SALES
       FROM ORDERS
       GROUP BY TOTAL_YEARS
       ORDER BY TOTAL_SALES DESC;
       
       SELECT O.SUB_CATEGORY,
       COUNT(O.ORDER_ID) AS TOTAL_ORDERS,
       COUNT(R.RETURN_ID),
       SUM(O.SALE)
FROM ORDERS AS O
INNER JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID
LEFT JOIN RETURNS AS R
ON O.ORDER_ID = R.ORDER_ID
WHERE O.CATEGORY IS NOT NULL AND TRIM(CATEGORY) <> ''
GROUP BY O.SUB_CATEGORY
ORDER BY TOTAL_ORDERS ASC;
       
       
-- END OF QUERIES FOR EXCEL VISUALIZATION ---------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

















